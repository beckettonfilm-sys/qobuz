<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Qobuz – Album Browser</title>
<style>
/* --- Layout / header --- */
body {
  font-family: Arial, sans-serif;
  background:#f5f5f5;
  margin:0;
  padding:0;
}
header {
  display:flex;
  justify-content:space-between;
  align-items:center;
  background:#1e1e1e;
  color:white;
  padding:10px 16px;
  gap:12px;
}
.nav-links {
  display:flex;
  gap:14px;
  align-items:center;
}
.nav-item {
  display:flex;
  align-items:center;
  gap:8px;
  cursor:pointer;
  color:white;
  font-weight:bold;
  transition: color .2s;
  font-size:0.95rem;
}
.nav-item .count { font-weight:normal; font-size:.8rem; color:#bbb; margin-left:6px; }
.nav-item .circle { width:10px; height:10px; border-radius:50%; border:2px solid #4CAF50; }
.nav-item.active .circle { background:#4CAF50; }

.header-controls {
  display:flex;
  gap:10px;
  align-items:center;
  flex-wrap:wrap;
}
.header-controls button, .header-controls input[type="date"] {
  background:#4CAF50;
  color:#fff;
  border-radius:5px;
  padding:6px 10px;
  border:none;
  font-weight:bold;
  cursor:pointer;
  font-size:.85rem;
}
.header-controls button { background:#1976D2; }
.header-controls select, .header-controls input[type="date"] { padding:6px; }
.header-controls select {
  background:#fff;
  color:#1e1e1e;
  border:1px solid #c5e1a5;
  border-radius:6px;
  font-weight:bold;
}

/* folder control small buttons */
.folder-controls { display:flex; gap:6px; align-items:center; margin-left:6px; }
.folder-controls button { padding:6px 8px; font-weight:bold; border-radius:5px; border:none; cursor:pointer; background:#388E3C; color:white; }
.folder-controls button.delete { background:#D32F2F; }
.folder-controls button.export { background:#1976D2; }
.folder-controls button.edit { background:#F57C00; }

.folder-area select { min-width:170px; }

.mode-switch {
  background:#263238;
  color:#fff;
  border:none;
  border-radius:18px;
  padding:6px 14px;
  font-weight:bold;
  cursor:pointer;
  transition:background .2s ease, color .2s ease;
}
.mode-switch.mode-k {
  background:#5e35b1;
}

.nav-refresh {
  background:#2d2d2d;
  color:#fff;
  border:none;
  border-radius:50%;
  width:28px;
  height:28px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-weight:bold;
  cursor:pointer;
  transition:background .2s ease, color .2s ease;
  margin-left:6px;
}
.nav-refresh:hover { background:#546e7a; }
.nav-refresh.needs-refresh { background:#ffca28; color:#1e1e1e; }

/* label filter panel */
#label-filter-panel {
  position:absolute;
  top:56px;
  right:20px;
  background:#fff;
  color:#000;
  padding:10px;
  border-radius:6px;
  box-shadow:0 8px 24px rgba(0,0,0,0.15);
  max-height:320px;
  overflow:auto;
  display:none;
  z-index:40;
}

/* main grid */
main { padding:18px; }
.albums-container {
  display:grid;
  grid-template-columns: repeat(6, 1fr);
  gap:15px;
}

.album-card {
  background: #fff;
  border-radius: 10px;
  border-width: 3px;
  border-style: solid;
  border-color: var(--card-border-color, rgba(200,0,0,0.25));
  box-shadow: 0 2px 6px rgba(0,0,0,0.1);
  overflow: hidden;
  display: flex;
  flex-direction: column;
  font-size: .9rem;
  text-decoration: none;
  color: inherit;
  position: relative;
  transition: transform .25s ease, box-shadow .25s ease, border-color .25s ease, border-width .25s ease;
}

.album-card:hover {
  transform: scale(1.05);
  box-shadow: 0 6px 20px rgba(0,0,0,0.25);
  border-color: var(--card-hover-color, rgba(200,0,0,1));
  border-width: 8px;
}

/* card internals */
.album-cover { width:100%; display:block; min-height:120px; object-fit:cover; background:#ddd; }
.album-info {
  padding:8px;
  display:flex;
  flex-direction:column;
  gap:4px;
  flex-grow:1;
  background: var(--album-info-bg, #fff);
  transition: background-color .25s ease, background .25s ease;
}
.album-title { font-weight:bold; font-size:.85rem; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; display:flex; align-items:center; gap:8px; }
.album-artist { font-size:.75rem; color:#555; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.album-meta { font-size:.72rem; color:#777; }

.album-label-icon {
  position:absolute;
  bottom:6px;
  right:6px;
  width:56px;
  height:28px;
  object-fit:contain;
  pointer-events:auto;
  cursor:pointer;
  opacity:0.95;
  background:transparent;
  border-radius:3px;
}

.album-cover.grayscale { filter:grayscale(100%); transition:filter .25s ease; }
.album-card:hover .album-cover.grayscale { filter:grayscale(0%); }

.nav-item { transition: color .25s ease; }

.pagination { margin-top:18px; display:flex; justify-content:center; gap:15px; align-items:center; flex-wrap:wrap; }
.pagination button { padding:8px 12px; border-radius:6px; border:none; background:#2196F3; color:white; cursor:pointer; font-weight:bold; }
.pagination button:disabled { background:#aaa; cursor:not-allowed; }
.pagination-info {
  display:flex;
  flex-direction:row;
  align-items:center;
  justify-content:center;
  gap:12px;
  min-width:auto;
}
.pagination-info label {
  display:flex;
  align-items:center;
  gap:6px;
  font-size:.85rem;
  color:#333;
  margin:0;
}
.page-info { font-weight:bold; color:#333; }
.pagination-info select { padding:6px 8px; border-radius:6px; border:1px solid #ccc; font-weight:bold; cursor:pointer; }
.pagination-info select:disabled { cursor:not-allowed; background:#eee; color:#777; }

/* folder dot near title */
.folder-dot {
  width:0.8em;
  height:0.8em;
  border-radius:50%;
  display:inline-block;
  flex: 0 0 auto;
}

/* default colors applied dynamically; we keep placeholder */
.folder-dot.green { background:#2e7d32; }
.folder-dot.yellow { background:#b58900; }

/* small responsive tweaks */
@media (max-width:1200px) {
  .albums-container { grid-template-columns: repeat(4,1fr); }
}
@media (max-width:800px) {
  header { flex-wrap:wrap; gap:8px; }
  .albums-container { grid-template-columns: repeat(2,1fr); }
}

/* hidden file input */
#realFileInput { display:none; }

#fileStatus {
  position:fixed;
  left:12px;
  bottom:8px;
  font-size:0.7rem;
  color:#555;
  pointer-events:none;
  transition:color .2s ease;
  z-index:60;
}

#fileStatus.status-updated {
  color:#2e7d32;
  font-weight:bold;
}

/* tooltip for folder options in select (some browsers won't show custom tooltip, but HTML title is set on option) */
.entity-dialog-backdrop {
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.45);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:2000;
}

.entity-dialog {
  background:#fff;
  color:#1e1e1e;
  padding:20px;
  border-radius:12px;
  width:min(360px, 90vw);
  box-shadow:0 18px 48px rgba(0,0,0,0.25);
  display:flex;
  flex-direction:column;
  gap:12px;
  font-family:inherit;
}

.entity-dialog h3 {
  margin:0;
  font-size:1.05rem;
}

.entity-dialog label {
  font-weight:bold;
  font-size:0.85rem;
}

.entity-dialog input[type="text"],
.entity-dialog select,
.entity-dialog input[type="color"] {
  width:100%;
  padding:8px;
  border-radius:6px;
  border:1px solid #c5e1a5;
  font-size:0.9rem;
  box-sizing:border-box;
}

.entity-dialog-actions {
  display:flex;
  justify-content:flex-end;
  gap:10px;
}

.entity-dialog-actions button {
  padding:8px 14px;
  border:none;
  border-radius:6px;
  cursor:pointer;
  font-weight:bold;
}

.entity-dialog-actions .confirm {
  background:#1976D2;
  color:#fff;
}

.entity-dialog-actions .cancel {
  background:#9e9e9e;
  color:#fff;
}

.entity-dialog small {
  color:#616161;
  font-size:0.75rem;
}
</style>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body class="cat-A">

 <div class="nav-links" id="navLinks">
    <div class="nav-item active" data-page="DB"><div class="circle"></div><span class="nav-text">MUSIC</span> <span class="count" id="countDB">(0)</span></div>
    <div class="nav-item" data-page="NR"><div class="circle"></div><span class="nav-text">NEWS</span> <span class="count" id="countNR">(0)</span></div>
    <div class="nav-item" data-page="FD"><div class="circle"></div><span class="nav-text">FOLDERS</span> <span class="count" id="countFD">(0)</span></div>
    <div class="nav-item" data-page="CS"><div class="circle"></div><span class="nav-text">SOON</span> <span class="count" id="countCS">(0)</span></div>
    <button id="foldersRefreshBtn" class="nav-refresh" title="Odśwież widok folderów">R</button>
  </div>

  <div class="header-controls">
    <button id="updateBtn">AKTUALIZUJ</button>

     <!-- single XLSX button -->
    <input id="realFileInput" type="file" accept=".xlsx" />
    <button id="xlsxBtn">XLSX</button>

      <div class="folder-area" style="display:flex;align-items:center;gap:8px;">
        <select id="containerSelect" title="Wybierz kontener (widok FOLDERS)">
        <option value="__all__">wszystkie kontenery</option>
      </select>
        <select id="folderSelect" title="Wybierz folder (widok FOLDERS)">
        <option value="__all__">wszystkie</option>
      </select>
      <div class="folder-controls" style="margin-left:6px;">
        <button id="newFolderBtn">+</button>
        <button id="editFolderBtn" class="edit">E</button>
        <button id="deleteFolderBtn" class="delete">-</button>
        <button id="exportFolderBtn" class="export">⇩</button>
      </div>
      <button id="modeSwitch" class="mode-switch" title="Przełącz tryb zarządzania: F - foldery, K - kontenery">F</button>
    </div>

    <input type="date" id="dateFrom" title="Data od" />
    <input type="date" id="dateTo" title="Data do" />

    <button id="labelFilterBtn">LABEL</button>
  </div>
</header>

<div id="label-filter-panel"></div>

<main>
  <div class="albums-container" id="albumsContainer"></div>

  <div class="pagination">
    <button id="prevBtn" disabled>Poprzedni</button>
    <div class="pagination-info">
      <span class="page-info" id="pageInfo">Strona 0 z 0</span>
      <label for="pageSelect">
        Idź do:
        <select id="pageSelect" disabled></select>
      </label>
    </div>
    <button id="nextBtn" disabled>Następny</button>
  </div>
</main>

<div id="fileStatus"></div>

<script>
/* ======= Elementy DOM ======= */
const albumsContainer = document.getElementById('albumsContainer');
const realFileInput = document.getElementById('realFileInput');
const xlsxBtn = document.getElementById('xlsxBtn');
const updateBtn = document.getElementById('updateBtn');
const folderSelect = document.getElementById('folderSelect');
const containerSelect = document.getElementById('containerSelect');
const dateFromInput = document.getElementById('dateFrom');
const dateToInput = document.getElementById('dateTo');
const labelFilterBtn = document.getElementById('labelFilterBtn');
const labelFilterPanel = document.getElementById('label-filter-panel');
const newFolderBtn = document.getElementById('newFolderBtn');
const deleteFolderBtn = document.getElementById('deleteFolderBtn');
const exportFolderBtn = document.getElementById('exportFolderBtn');
const editFolderBtn = document.getElementById('editFolderBtn');
const modeSwitch = document.getElementById('modeSwitch');
const foldersRefreshBtn = document.getElementById('foldersRefreshBtn');
const fileStatusEl = document.getElementById('fileStatus');

const navItems = Array.from(document.querySelectorAll('.nav-item'));
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const pageInfo = document.getElementById('pageInfo');
const pageSelect = document.getElementById('pageSelect');

let records = [];
let currentFileHandle = null;
let currentFileName = '';
let currentFileTimestamp = '';
let currentSheetName = '';
let statusTimeout = null;
let foldersList = new Set(['brak']);
let containersList = new Set(['brak']);
let folderMeta = new Map();
let containerMeta = new Map();
let managementMode = 'F';
let foldersNeedRefresh = false;
let selectedLabels = new Set();
let autoDataLoaded = false;
let loadRetryTimer = null;

const DEFAULT_FOLDER_COLOR = '#2e7d32';
const DEFAULT_CONTAINER_COLOR = '#1976d2';
const DEFAULT_EMPTY_COLOR = '#9e9e9e';

clearFileStatus();
let hierarchy = [
"01A - ECM New Series","02A - Deutsche Grammophon (DG)","03A - Chandos","04A - Sony Classical",
"05A - Decca Music Group Ltd.","06A - Harmonia mundi","07A - Alpha Classics","08A - PENTATONE",
"09A - Channel Classics","10B - Hyperion","11B - BIS","12B - Warner Classics / Erato",
"13B - Delphian Records","14B - Lawo Classics","15B - Naxos","16B - Signum Records",
"17B - LSO Live","18B - Berlin Classics","19C - Aparté","20C - Orchid Classics",
"21C - Fuga Libera","22C - Ondine","23C - Evidence Classics","24C - Navona","25C - Ricercar",
"26C - Arcana","27C - Nonesuch","28C - Linn Records","29C - AVIE Records","30C - Naive",
"31C - Rubicon","32C - Mirare","33C - CPO","34C - Brilliant Classics","35C - Capriccio",
"36C - BR-Klassik","37C - Resonus Classics","38C - Onyx Classics","39C - First Hand Records",
"40C - Piano Classics","41C - Hänssler CLASSIC","42C - Grand Piano","43C - Bright Shiny Things"
];
const labelMap = {};
hierarchy.forEach(l=>{
  const [code,name]=l.split(" - ");
  labelMap[name.trim()]=code;
});

function getLabelOrderCode(label){
  const code = labelMap[label];
  return code ? parseInt(code, 10) : 999;
}

function compareByReleaseDesc(a,b){
  const diff = (b.release_date||0) - (a.release_date||0);
  if(diff !== 0) return diff;
  const labelDiff = getLabelOrderCode(a.label) - getLabelOrderCode(b.label);
  if(labelDiff !== 0) return labelDiff;
  return (a.title||'').localeCompare(b.title||'', 'pl', { sensitivity:'base' });
}

function compareByAddedDesc(a,b){
  const diff = (b.added_ts||0) - (a.added_ts||0);
  if(diff !== 0) return diff;
  return compareByReleaseDesc(a,b);
}

const albumsPerPage = 12;
let currentCategory = 'DB';
let currentPage = 0;
let categorized = { DB:[], NR:[], FD:[], CS:[] };

function findRecordForAlbum(album){
  if(!album) return null;
  if(records.includes(album)) return album;
  if(album.link){
    const match = records.find(r => r.link === album.link);
    if(match) return match;
  }
  return records.find(r => r === album) || null;
}

function syncRecord(album, updates){
  const rec = findRecordForAlbum(album);
  if(!rec || !updates) return;
  Object.assign(rec, updates);
}

function getCurrentList(){
  let list = categorized[currentCategory] || [];

  if(currentCategory==='FD'){
    if(folderSelect.value !== '__all__'){
      const fld = folderSelect.value;
      list = records
        .filter(r => (r.folder || 'brak') === fld)
        .map(rec=>{
          if(typeof rec.added_ts !== 'number'){
            const info = parseAddedField(rec.added);
            rec.added = info.text;
            rec.added_ts = info.ts;
          }
          return rec;
        })
        .sort(compareByAddedDesc);
    } else {
      const selectedContainer = containerSelect.value;
      list = categorized.FD || [];
      if(selectedContainer && selectedContainer !== '__all__'){
        list = list.filter(item => (item.container || 'brak') === selectedContainer);
      }
    }
  }

  return list;
}

/* ======= Helpers: daty i status pliku ======= */
function formatAddedString(date){
  const pad = n=>String(n).padStart(2,'0');
  return `${pad(date.getDate())}.${pad(date.getMonth()+1)}.${date.getFullYear()}-${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
}

function formatStatusDate(date){
  const pad = n=>String(n).padStart(2,'0');
  return `${pad(date.getDate())}.${pad(date.getMonth()+1)}.${date.getFullYear()} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
}

function parseAddedField(value){
  if(value === undefined || value === null || value === '') return { text:'', ts:0 };
  if(typeof value === 'number' && XLSX?.SSF?.parse_date_code){
    const decoded = XLSX.SSF.parse_date_code(value);
    if(decoded){
      const dt = new Date(decoded.y, (decoded.m||1)-1, decoded.d||1, decoded.H||0, decoded.M||0, Math.floor(decoded.S||0));
      if(!Number.isNaN(dt.getTime())){
        return { text: formatAddedString(dt), ts: dt.getTime() };
      }
    }
  }
  if(typeof value === 'string'){
    const trimmed = value.trim();
    if(!trimmed) return { text:'', ts:0 };
    const match = trimmed.match(/^(\d{2})\.(\d{2})\.(\d{4})[-\s](\d{2}):(\d{2}):(\d{2})$/);
    if(match){
      const dt = new Date(Number(match[3]), Number(match[2])-1, Number(match[1]), Number(match[4]), Number(match[5]), Number(match[6]));
      if(!Number.isNaN(dt.getTime())){
        return { text: formatAddedString(dt), ts: dt.getTime() };
      }
    }
    const parsed = new Date(trimmed);
    if(!Number.isNaN(parsed.getTime())){
      return { text: formatAddedString(parsed), ts: parsed.getTime() };
    }
    return { text: trimmed, ts:0 };
  }
  return { text:'', ts:0 };
}

function parseReleaseDateValue(value){
  if(value === undefined || value === null || value === '') return 0;
  if(typeof value === 'number'){
    if(value > 1000000000000) return Math.floor(value/1000);
    if(value > 1000000000) return Math.floor(value);
    if(XLSX?.SSF?.parse_date_code){
      const decoded = XLSX.SSF.parse_date_code(value);
      if(decoded){
        const dt = new Date(decoded.y, (decoded.m||1)-1, decoded.d||1, decoded.H||0, decoded.M||0, Math.floor(decoded.S||0));
        if(!Number.isNaN(dt.getTime())){
          return Math.floor(dt.getTime()/1000);
        }
      }
    }
    return 0;
  }
  if(typeof value === 'string'){
    const trimmed = value.trim();
    if(!trimmed) return 0;
    if(/^-?\d+$/.test(trimmed)){
      const num = parseInt(trimmed,10);
      if(num > 1000000000000) return Math.floor(num/1000);
      return num;
    }
    const parsed = new Date(trimmed);
    if(!Number.isNaN(parsed.getTime())){
      return Math.floor(parsed.getTime()/1000);
    }
  }
  return 0;
}

function sanitizeName(value){
  if(value === undefined || value === null) return '';
  return String(value).trim();
}

function normalizeColor(value, fallback){
  if(typeof value === 'string'){
    let trimmed = value.trim();
    if(!trimmed) return fallback;
    if(!trimmed.startsWith('#') && /^([0-9a-f]{3}|[0-9a-f]{6})$/i.test(trimmed)){
      trimmed = `#${trimmed}`;
    }
    if(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(trimmed)){
      return trimmed.toLowerCase();
    }
  }
  return fallback;
}

function baseStatusText(){
  if(!currentFileName) return '';
  return currentFileTimestamp ? `${currentFileName} ${currentFileTimestamp}` : currentFileName;
}

function refreshFileStatus(){
  if(!fileStatusEl) return;
  clearTimeout(statusTimeout);
  statusTimeout = null;
  fileStatusEl.classList.remove('status-updated');
  fileStatusEl.textContent = baseStatusText();
}

function flashFileUpdated(){
  if(!fileStatusEl) return;
  clearTimeout(statusTimeout);
  fileStatusEl.classList.add('status-updated');
  fileStatusEl.textContent = 'ZAKTUALIZOWANO';
  statusTimeout = setTimeout(()=>{
    fileStatusEl.classList.remove('status-updated');
    fileStatusEl.textContent = baseStatusText();
  }, 2000);
}

function clearFileStatus(){
  if(!fileStatusEl) return;
  clearTimeout(statusTimeout);
  statusTimeout = null;
  fileStatusEl.classList.remove('status-updated');
  fileStatusEl.textContent = '';
}

function convertRowToRecord(row){
  row = row || {};
  const selectorRaw = (row.SELECTOR ?? row.SETECTOR ?? 'N');
  const selector = String(selectorRaw || 'N').trim() || 'N';
  const folder = String(row.FOLDER ?? 'brak').trim() || 'brak';
  const container = String(row.KONTENER ?? row.CONTAINER ?? 'brak').trim() || 'brak';
  const addedInfo = parseAddedField(row.ADDED);
  const releaseDate = parseReleaseDateValue(row.RELEASE_DATE);
  const folderColor = normalizeColor(row.Col_F ?? row.COL_F ?? row.col_f, folder === 'brak' ? DEFAULT_EMPTY_COLOR : DEFAULT_FOLDER_COLOR);
  const containerColor = normalizeColor(row.Col_K ?? row.COL_K ?? row.col_k, container === 'brak' ? DEFAULT_EMPTY_COLOR : DEFAULT_CONTAINER_COLOR);
  return {
    selector,
    origSelector: selector,
    folder,
    container,
    added: addedInfo.text,
    added_ts: addedInfo.ts,
    label: String(row.LABEL ?? ''),
    link: String(row.LINK ?? ''),
    picture: String(row.PICTURE ?? ''),
    artist: String(row.ARTIST ?? ''),
    title: String(row.TITLE ?? ''),
    duration: Number(row.DURATION) || 0,
    release_date: releaseDate,
    release_original: row.RELEASE_DATE,
    col_f: folderColor,
    col_k: containerColor
  };
}

function rebuildMetaStructures(){
  foldersList = new Set(['brak']);
  containersList = new Set(['brak']);
  folderMeta = new Map();
  containerMeta = new Map();
  containerMeta.set('brak', { color: DEFAULT_EMPTY_COLOR, folders: new Set() });
  folderMeta.set('brak', { color: DEFAULT_EMPTY_COLOR, container: 'brak' });

  records.forEach(rec => {
    const folderName = sanitizeName(rec.folder) || 'brak';
    const containerName = sanitizeName(rec.container) || 'brak';
    const folderColor = normalizeColor(rec.col_f, folderName === 'brak' ? DEFAULT_EMPTY_COLOR : DEFAULT_FOLDER_COLOR);
    const containerColor = normalizeColor(rec.col_k, containerName === 'brak' ? DEFAULT_EMPTY_COLOR : DEFAULT_CONTAINER_COLOR);

    rec.folder = folderName;
    rec.container = containerName;
    rec.col_f = folderColor;
    rec.col_k = containerColor;

    foldersList.add(folderName);
    containersList.add(containerName);

    if(!containerMeta.has(containerName)){
      containerMeta.set(containerName, { color: containerColor, folders: new Set() });
    }
    const cont = containerMeta.get(containerName);
    cont.color = normalizeColor(containerColor, cont.color || (containerName === 'brak' ? DEFAULT_EMPTY_COLOR : DEFAULT_CONTAINER_COLOR));
    if(!cont.folders) cont.folders = new Set();
    if(folderName !== 'brak') cont.folders.add(folderName);

    if(!folderMeta.has(folderName)){
      folderMeta.set(folderName, { color: folderColor, container: containerName });
    }
    const fld = folderMeta.get(folderName);
    fld.color = normalizeColor(folderColor, fld.color || (folderName === 'brak' ? DEFAULT_EMPTY_COLOR : DEFAULT_FOLDER_COLOR));
    fld.container = containerName;
  });
}

function ensureContainerEntry(name){
  const key = name || 'brak';
  if(!containersList.has(key)) containersList.add(key);
  if(!containerMeta.has(key)){
    containerMeta.set(key, { color: key === 'brak' ? DEFAULT_EMPTY_COLOR : DEFAULT_CONTAINER_COLOR, folders: new Set() });
  }
  const meta = containerMeta.get(key);
  if(!meta.folders) meta.folders = new Set();
  return meta;
}

function ensureFolderEntry(name, container){
  const key = name || 'brak';
  if(!foldersList.has(key)) foldersList.add(key);
  if(!folderMeta.has(key)){
    folderMeta.set(key, { color: key === 'brak' ? DEFAULT_EMPTY_COLOR : DEFAULT_FOLDER_COLOR, container: container || 'brak' });
  }
  const meta = folderMeta.get(key);
  if(container !== undefined){
    meta.container = container;
  }
  return meta;
}

function getFolderColor(name){
  const meta = folderMeta.get(name);
  return normalizeColor(meta?.color, name === 'brak' ? DEFAULT_EMPTY_COLOR : DEFAULT_FOLDER_COLOR);
}

function getContainerColor(name){
  const meta = containerMeta.get(name);
  return normalizeColor(meta?.color, name === 'brak' ? DEFAULT_EMPTY_COLOR : DEFAULT_CONTAINER_COLOR);
}

function getCustomFolderCount(){
  return Array.from(foldersList).filter(f=>f!=='brak').length;
}

function getCustomContainerCount(){
  return Array.from(containersList).filter(c=>c!=='brak').length;
}

function applyRecordsList(newRecords, meta={}){
  records = Array.isArray(newRecords) ? newRecords : [];
  rebuildMetaStructures();
  rebuildContainerSelect();
  rebuildFolderSelect();
  buildLabelFilterPanel();
  currentPage = 0;
  clearFoldersPending();
  processAndRender();

  if(meta.sheetName){
    currentSheetName = meta.sheetName;
  }
  if(meta.fileName){
    currentFileName = meta.fileName;
  }
  if('timestamp' in meta || 'lastModified' in meta){
    let ts = null;
    if(meta.timestamp){
      const dt = new Date(meta.timestamp);
      if(!Number.isNaN(dt.getTime())) ts = dt;
    }
    if(!ts && meta.lastModified){
      const dt = new Date(meta.lastModified);
      if(!Number.isNaN(dt.getTime())) ts = dt;
    }
    currentFileTimestamp = ts ? formatStatusDate(ts) : '';
  }
  refreshFileStatus();
}

async function loadWorkbookFromFile(file){
  if(!file) return;
  try {
    const buffer = await file.arrayBuffer();
    const workbook = XLSX.read(buffer, { type: 'array' });
    currentSheetName = workbook.SheetNames[0] || 'Sheet1';
    const sheet = workbook.Sheets[currentSheetName];
    const rows = XLSX.utils.sheet_to_json(sheet, { defval: '' });
    const parsed = rows.map(convertRowToRecord);
    applyRecordsList(parsed, {
      sheetName: currentSheetName,
      fileName: currentFileName,
      lastModified: file.lastModified || Date.now()
    });
    alert(`✅ Załadowano ${records.length} rekordów z pliku XLSX`);
  } catch(err){
    console.error(err);
    alert('❌ Wystąpił problem podczas wczytywania pliku XLSX: ' + (err?.message || err));
  }
}

/* ======= Wczytywanie pliku XLSX ======= */
xlsxBtn.addEventListener('click', async ()=>{
  if(window.showOpenFilePicker){
    try {
      const [handle] = await window.showOpenFilePicker({
        multiple: false,
        types: [
          {
            description: 'Pliki Excel',
            accept: { 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'] }
          }
        ]
      });
      if(!handle) return;
      currentFileHandle = handle;
      const file = await handle.getFile();
      currentFileName = handle.name || file.name || 'data.xlsx';
      currentFileTimestamp = formatStatusDate(new Date(file.lastModified || Date.now()));
      refreshFileStatus();
      await loadWorkbookFromFile(file);
    } catch(err){
      if(err?.name === 'AbortError') return;
      console.error(err);
      alert('Nie udało się wczytać pliku XLSX: ' + (err?.message || err));
    }
  } else {
    realFileInput.click();
  }
});

realFileInput.addEventListener('change', async e=>{
  const file = e.target.files?.[0];
  if(!file) return;
  currentFileHandle = null;
  currentFileName = file.name || 'data.xlsx';
  currentFileTimestamp = formatStatusDate(new Date(file.lastModified || Date.now()));
  refreshFileStatus();
  await loadWorkbookFromFile(file);
  realFileInput.value = '';
});

/* ======= Folder counts and rebuild ======= */
function getFolderCounts(containerFilter){
  const map = {};
  foldersList.forEach(f => map[f] = 0);
  records.forEach(r => {
    const fld = sanitizeName(r.folder) || 'brak';
    const cont = sanitizeName(r.container) || 'brak';
    if(containerFilter && containerFilter !== '__all__' && cont !== containerFilter) return;
    if(!(fld in map)) map[fld] = 0;
    map[fld]++;
  });
  return map;
}

function getContainerCounts(){
  const map = {};
  containersList.forEach(c => map[c] = 0);
  records.forEach(r => {
    const cont = sanitizeName(r.container) || 'brak';
    if(!(cont in map)) map[cont] = 0;
    map[cont]++;
  });
  return map;
}

/* truncate helper: show up to n chars, add ellipsis if longer */
function truncateName(name, n){
  if(!name) return '';
  if(name.length <= n) return name;
  return name.slice(0,n) + '…';
}

function optionSetColor(option, color){
  option.style.color = color;
}

function markFoldersPending(){
  foldersNeedRefresh = true;
  foldersRefreshBtn?.classList.add('needs-refresh');
}

function clearFoldersPending(){
  foldersNeedRefresh = false;
  foldersRefreshBtn?.classList.remove('needs-refresh');
}

function assignAlbumToFolder(album, targetFolder){
  if(!album || !targetFolder || targetFolder === '__all__') return;
  const normalizedTarget = targetFolder;
  const currentFolder = album.folder || 'brak';
  if(normalizedTarget === currentFolder) return;

  if(normalizedTarget !== 'brak' && !folderMeta.has(normalizedTarget)){
    alert('Wybrany folder nie istnieje w aktualnej liście.');
    return;
  }

  let updates = {};
  const oldFolder = currentFolder;
  const oldContainer = album.container || 'brak';

  if(normalizedTarget === 'brak'){
    album.folder = 'brak';
    album.container = 'brak';
    album.added = '';
    album.added_ts = 0;
    album.col_f = DEFAULT_EMPTY_COLOR;
    album.col_k = getContainerColor('brak');
    updates = { folder: 'brak', container: 'brak', added: '', added_ts: 0, col_f: album.col_f, col_k: album.col_k };
  } else {
    const folderInfo = folderMeta.get(normalizedTarget) || ensureFolderEntry(normalizedTarget, 'brak');
    foldersList.add(normalizedTarget);
    const containerName = folderInfo.container || 'brak';
    const now = new Date();
    const addedStr = formatAddedString(now);
    album.folder = normalizedTarget;
    album.container = containerName;
    album.added = addedStr;
    album.added_ts = now.getTime();
    album.col_f = getFolderColor(normalizedTarget);
    album.col_k = getContainerColor(containerName);
    ensureContainerEntry(containerName).folders.add(normalizedTarget);
    updates = { folder: normalizedTarget, container: containerName, added: addedStr, added_ts: album.added_ts, col_f: album.col_f, col_k: album.col_k };
  }

  if(oldFolder !== 'brak'){
    const oldMeta = folderMeta.get(oldFolder);
    if(oldMeta && oldMeta.container){
      ensureContainerEntry(oldMeta.container);
    }
  }
  if(oldContainer && oldContainer !== 'brak'){
    ensureContainerEntry(oldContainer);
  }

  syncRecord(album, updates);
  markFoldersPending();
  processAndRender();
}

function openEntityDialog({ mode = 'folder', title = '', defaultName = '', defaultColor, defaultContainer = 'brak' } = {}){
  return new Promise(resolve => {
    const backdrop = document.createElement('div');
    backdrop.className = 'entity-dialog-backdrop';

    const dialog = document.createElement('div');
    dialog.className = 'entity-dialog';

    const heading = document.createElement('h3');
    heading.textContent = title || (mode === 'folder' ? 'Nowy folder' : 'Nowy kontener');
    dialog.appendChild(heading);

    const nameLabel = document.createElement('label');
    nameLabel.textContent = 'Nazwa';
    dialog.appendChild(nameLabel);

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.maxLength = 50;
    nameInput.value = defaultName || '';
    dialog.appendChild(nameInput);

    const colorLabel = document.createElement('label');
    colorLabel.textContent = 'Kolor';
    dialog.appendChild(colorLabel);

    const colorInput = document.createElement('input');
    colorInput.type = 'color';
    const fallbackColor = mode === 'folder' ? DEFAULT_FOLDER_COLOR : DEFAULT_CONTAINER_COLOR;
    colorInput.value = normalizeColor(defaultColor, fallbackColor) || fallbackColor;
    dialog.appendChild(colorInput);

    let containerSelectEl = null;
    if(mode === 'folder'){
      const contLabel = document.createElement('label');
      contLabel.textContent = 'Kontener';
      dialog.appendChild(contLabel);

      containerSelectEl = document.createElement('select');
      const containerNames = Array.from(containersList).filter(c=>c!=='brak').sort((a,b)=>a.localeCompare(b,'pl'));
      const ordered = ['brak', ...containerNames];
      ordered.forEach(name => {
        ensureContainerEntry(name);
        const opt = document.createElement('option');
        opt.value = name;
        const display = name === 'brak' ? 'brak' : name;
        const truncated = display.length > 20 ? truncateName(display, 20) : display;
        opt.textContent = `● ${truncated}`;
        optionSetColor(opt, getContainerColor(name));
        containerSelectEl.appendChild(opt);
      });
      containerSelectEl.value = containersList.has(defaultContainer) ? defaultContainer : 'brak';
      dialog.appendChild(containerSelectEl);
    }

    const hint = document.createElement('small');
    hint.textContent = 'Dozwolone maksymalnie 50 znaków (w tym spacje).';
    dialog.appendChild(hint);

    const actions = document.createElement('div');
    actions.className = 'entity-dialog-actions';
    const cancelBtn = document.createElement('button'); cancelBtn.className = 'cancel'; cancelBtn.textContent = 'Anuluj';
    const confirmBtn = document.createElement('button'); confirmBtn.className = 'confirm'; confirmBtn.textContent = 'Zapisz';
    actions.appendChild(cancelBtn);
    actions.appendChild(confirmBtn);
    dialog.appendChild(actions);

    function close(result){
      backdrop.remove();
      document.removeEventListener('keydown', onKeyDown);
      resolve(result);
    }

    function onKeyDown(e){
      if(e.key === 'Escape'){ e.preventDefault(); close(null); }
      if(e.key === 'Enter'){ e.preventDefault(); confirmBtn.click(); }
    }

    cancelBtn.addEventListener('click', ()=>close(null));
    confirmBtn.addEventListener('click', ()=>{
      const result = {
        name: nameInput.value.trim(),
        color: normalizeColor(colorInput.value, mode === 'folder' ? DEFAULT_FOLDER_COLOR : DEFAULT_CONTAINER_COLOR)
      };
      if(mode === 'folder'){
        result.container = containerSelectEl?.value || 'brak';
      }
      close(result);
    });

    backdrop.addEventListener('click', e=>{ if(e.target === backdrop) close(null); });
    document.addEventListener('keydown', onKeyDown);

    backdrop.appendChild(dialog);
    document.body.appendChild(backdrop);
    setTimeout(()=> nameInput.focus(), 0);
  });
}

function rebuildContainerSelect(){
  const prev = containerSelect.value;
  const counts = getContainerCounts();
  containerSelect.innerHTML = '';
  const allOpt = document.createElement('option');
  allOpt.value = '__all__';
  allOpt.textContent = 'wszystkie kontenery';
  containerSelect.appendChild(allOpt);

  const others = Array.from(containersList).filter(c=>c!=='brak').sort((a,b)=>a.localeCompare(b,'pl'));
  const ordered = ['brak', ...others];

  ordered.forEach(contName => {
    if(!containerMeta.has(contName)){
      containerMeta.set(contName, { color: contName === 'brak' ? DEFAULT_EMPTY_COLOR : DEFAULT_CONTAINER_COLOR, folders: new Set() });
    }
    const opt = document.createElement('option');
    opt.value = contName;
    const display = contName === 'brak' ? 'brak' : contName;
    const truncated = display.length > 18 ? truncateName(display, 18) : display;
    const count = counts[contName] || 0;
    opt.textContent = `● ${truncated} (${count})`;
    opt.title = contName;
    optionSetColor(opt, getContainerColor(contName));
    containerSelect.appendChild(opt);
  });

  if(prev && Array.from(containerSelect.options).some(o=>o.value===prev)){
    containerSelect.value = prev;
  } else {
    containerSelect.value = '__all__';
  }
}

/* rebuild folder select while preserving selection if possible */
function rebuildFolderSelect(){
  const prev = folderSelect.value;
  const selectedContainer = containerSelect.value;
  const counts = getFolderCounts(selectedContainer);
  folderSelect.innerHTML = '';
  const allOpt = document.createElement('option');
  allOpt.value='__all__';
  allOpt.textContent = 'wszystkie';
  allOpt.title = 'Pokaż wszystkie';
  folderSelect.appendChild(allOpt);

  const available = Array.from(foldersList).filter(f=>{
    if(f === 'brak') return true;
    const meta = folderMeta.get(f);
    if(!selectedContainer || selectedContainer === '__all__') return true;
    return meta?.container === selectedContainer;
  });
  const others = available.filter(f=>f!=='brak').sort((a,b)=>a.localeCompare(b,'pl'));
  const full = ['brak', ...others];

  full.forEach(fld=>{
    const opt = document.createElement('option');
    opt.value = fld;
    const disp = fld === 'brak' ? 'brak' : fld;
    const truncated = (disp.length > 15) ? truncateName(disp, 15) : disp;
    const count = counts[fld] || 0;
    opt.textContent = `● ${truncated} (${count})`;
    opt.title = fld; // tooltip shows full name
    optionSetColor(opt, getFolderColor(fld));
    folderSelect.appendChild(opt);
  });

  if(prev && Array.from(folderSelect.options).some(o=>o.value===prev)){
    folderSelect.value = prev;
  } else {
    folderSelect.value = '__all__';
  }
}

/* ======= Label filter panel ======= */
function buildLabelFilterPanel(){
  labelFilterPanel.innerHTML = '<strong>Wybierz wytwórnie:</strong><div style="height:8px"></div>';
  selectedLabels = new Set();
  hierarchy.forEach(l=>{
    const [,name] = l.split(' - ');
    const id = 'lblchk_'+name.replace(/\s+/g,'_').replace(/[^\w\-]/g,'');
    const div = document.createElement('div');
    div.style.marginBottom='6px';
    const cb = document.createElement('input'); cb.type='checkbox'; cb.id=id; cb.value=name; cb.checked=true;
    cb.addEventListener('change', ()=>{
      if(cb.checked) selectedLabels.add(name); else selectedLabels.delete(name);
      processAndRender();
    });
    const lbl = document.createElement('label'); lbl.htmlFor=id; lbl.style.marginLeft='6px'; lbl.textContent=name;
    div.appendChild(cb); div.appendChild(lbl);
    labelFilterPanel.appendChild(div);
    selectedLabels.add(name);
  });
  const tools = document.createElement('div'); tools.style.marginTop='8px';
  const allBtn = document.createElement('button'); allBtn.textContent='Wszystkie'; allBtn.style.marginRight='6px';
  const noneBtn = document.createElement('button'); noneBtn.textContent='Brak';
  allBtn.onclick = ()=>{ Array.from(labelFilterPanel.querySelectorAll('input[type=checkbox]')).forEach(ch=>{ ch.checked=true; selectedLabels.add(ch.value); }); processAndRender(); };
  noneBtn.onclick = ()=>{ Array.from(labelFilterPanel.querySelectorAll('input[type=checkbox]')).forEach(ch=>{ ch.checked=false; selectedLabels.delete(ch.value); }); processAndRender(); };
  tools.appendChild(allBtn); tools.appendChild(noneBtn);
  labelFilterPanel.appendChild(tools);
}

labelFilterBtn.addEventListener('click', ()=>{
  labelFilterPanel.style.display = labelFilterPanel.style.display === 'block' ? 'none' : 'block';
});
document.addEventListener('click', (e)=>{
  if(!labelFilterPanel.contains(e.target) && e.target!==labelFilterBtn) labelFilterPanel.style.display='none';
});

/* ======= Core processing and rendering ======= */
function processAndRender(){
  categorized = { DB:[], NR:[], FD:[], CS:[] };
  const now = new Date();
  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate()).getTime()/1000;
  const dateFrom = dateFromInput.value ? new Date(dateFromInput.value).getTime()/1000 : null;
  const dateTo = dateToInput.value ? (new Date(dateToInput.value).getTime()/1000 + 86399) : null;

  records.forEach(rec=>{
    // filtr etykiet
    if(selectedLabels.size && !selectedLabels.has(rec.label)) return;
    // filtr dat
    if(dateFrom && rec.release_date && rec.release_date<dateFrom) return;
    if(dateTo && rec.release_date && rec.release_date>dateTo) return;

    const alb = rec; // używamy oryginału, bez kopiowania
    alb._durationNum = rec.duration;
    if(typeof alb.added_ts !== 'number'){
      const info = parseAddedField(alb.added);
      alb.added = info.text;
      alb.added_ts = info.ts;
    }
    alb.col_f = getFolderColor(alb.folder || 'brak');
    alb.col_k = getContainerColor(alb.container || 'brak');

    // Coming Soon: albumy < 30 minut
    if(alb._durationNum < 1800) categorized.CS.push(alb);

    // New Releases: ostatnie 7 dni
    const diffDays = alb.release_date ? Math.floor((todayStart - alb.release_date)/86400) : 9999;
    if(alb.release_date && diffDays >= 0 && diffDays <= 6) categorized.NR.push(alb);

    // Folder view collects albums przypisane do konkretnych folderów
    if(alb.folder && alb.folder !== 'brak') categorized.FD.push(alb);

    // DB (wszystkie)
    categorized.DB.push(alb);
    // collect folders
    if(alb.folder && alb.folder.trim()) foldersList.add(alb.folder);
  });

  // Wykluczamy NR i CS z DB
  const excludeIds = new Set();
    categorized.NR.forEach(a=>excludeIds.add(a.link));
  categorized.CS.forEach(a=>excludeIds.add(a.link));
  categorized.DB = categorized.DB.filter(a=>!excludeIds.has(a.link));

  categorized.DB.sort(compareByReleaseDesc);
  categorized.NR.sort(compareByReleaseDesc);
  categorized.FD.sort(compareByAddedDesc);
  categorized.CS.sort(compareByReleaseDesc);

  document.getElementById('countDB').textContent = `(${categorized.DB.length})`;
  document.getElementById('countNR').textContent = `(${categorized.NR.length})`;
  document.getElementById('countFD').textContent = `(${categorized.FD.length})`;
  document.getElementById('countCS').textContent = `(${categorized.CS.length})`;

  rebuildContainerSelect();
  rebuildFolderSelect();
  if(currentCategory !== 'FD' || !foldersNeedRefresh){
    renderAlbumsPage();
  }
}

function renderCategory(cat){
  currentCategory = cat; currentPage=0;
  document.body.classList.remove('cat-A','cat-B','cat-C','cat-D');
  if(cat==='NR') document.body.classList.add('cat-A');
  else if(cat==='FD') document.body.classList.add('cat-B');
  else if(cat==='DB') document.body.classList.add('cat-C');
  else if(cat==='CS') document.body.classList.add('cat-D');
  updateNavActive(cat);
  if(cat === 'FD' && foldersNeedRefresh){
    return;
  }
  renderAlbumsPage();
}

function updateNavActive(cat){
  navItems.forEach(it=>{
    it.classList.remove('active');
    if(it.dataset.page===cat) it.classList.add('active');
  });
}

function renderAlbumsPage(){
  const list = getCurrentList();

  const total = list.length;
  const totalPages = total ? Math.ceil(total / albumsPerPage) : 0;

  if(totalPages === 0) {
    currentPage = 0;
  } else {
    if(currentPage >= totalPages) currentPage = totalPages - 1;
    if(currentPage < 0) currentPage = 0;
  }

  const start = currentPage * albumsPerPage;
  const end = start + albumsPerPage;
  const pageItems = list.slice(start, end);

  albumsContainer.innerHTML = '';

  pageItems.forEach(album=>{
    const a = document.createElement('a');
    a.href = album.link || '#';
    a.target = '_blank';
    a.className = 'album-card';
    a.title = `${album.title} — ${album.artist}`;

    const img = document.createElement('img');
    img.className = 'album-cover';
    img.src = album.picture || '';
    if(album.selector==='X') img.classList.add('grayscale');

    const info = document.createElement('div');
    info.className = 'album-info';
    const t = document.createElement('div'); t.className='album-title';

    // folder dot if album is in a folder (not 'brak'); color depends on folder name starting with LIKE:
    if(album.folder && album.folder !== 'brak') {
      const dot = document.createElement('span');
      dot.className='folder-dot';
      dot.style.background = album.col_f || getFolderColor(album.folder);
      dot.title = album.folder;
      t.appendChild(dot);
    }

    const titleText = document.createElement('span');
    titleText.style.minWidth='0';
    titleText.textContent = album.title;
    t.appendChild(titleText);

    const ar = document.createElement('div'); ar.className='album-artist'; ar.textContent = album.artist;
   const m = document.createElement('div'); m.className='album-meta';
    const metaParts = [];
    if(album.release_date){
      const d = new Date(album.release_date*1000);
      const dateStr = `${d.getDate().toString().padStart(2,'0')}/${(d.getMonth()+1).toString().padStart(2,'0')}/${d.getFullYear()}`;
      metaParts.push(dateStr);
    }
    const dur = formatDuration(album.duration);
    if(dur !== 'brak') metaParts.push(dur);
    // Nie wyświetlamy informacji o dacie dodania albumu do folderu,
    // ale pozostawiamy dane w rekordzie, by logika sortowania działała bez zmian.
    m.textContent = metaParts.length ? metaParts.join(' • ') : 'brak danych';
    info.appendChild(t); info.appendChild(ar); info.appendChild(m);


    const code = labelMap[album.label] || '00A';
    const icon = document.createElement('img');
    icon.className = 'album-label-icon';
    icon.src = `${code}.svg`;
    icon.alt = album.label;
    icon.title = album.label;
    icon.addEventListener('click', ev=>{
      ev.preventDefault(); ev.stopPropagation();
      cycleSelector(album,img,a);
    });

    a.addEventListener('mouseenter', ()=>{ if(album.selector==='X') img.classList.remove('grayscale'); });
    a.addEventListener('mouseleave', ()=>{ if(album.selector==='X') img.classList.add('grayscale'); });

    applySelectorColorToCard(a, album.selector);

    // folder-assign via SHIFT + left click on the card
    a.addEventListener('click', (ev) => {
  if (ev.shiftKey && !ev.ctrlKey && !ev.metaKey && ev.button === 0) {
    ev.preventDefault();
    const target = folderSelect.value;
    if (target && target !== '__all__') {
      assignAlbumToFolder(album, target); // doda lub przeniesie (z folder_1 do folder_2)
    } else {
      alert('Wybierz konkretny folder z listy (nie "wszystkie").');
    }
  }
});


    // SHIFT + right click (context menu) przenosi album do wybranego folderu/kontenera
    a.addEventListener('contextmenu', (ev) => {
  if (ev.shiftKey && !ev.ctrlKey && !ev.metaKey) {
    ev.preventDefault();
    if (album.folder && album.folder !== 'brak') {
      assignAlbumToFolder(album, 'brak'); // „usunięcie” = wyrzucenie z folderu
    } else {
      // opcjonalnie
      // alert('Ten album nie jest w żadnym folderze.');
    }
    return;
  }
  // bez SHIFT: zwykłe menu przeglądarki
});

     a.appendChild(img); a.appendChild(info); a.appendChild(icon);
    albumsContainer.appendChild(a);
  });

  if(pageInfo){
    pageInfo.textContent = totalPages ? `Strona ${currentPage + 1} z ${totalPages}` : 'Strona 0 z 0';
  }

  if(pageSelect){
    pageSelect.innerHTML = '';
    if(totalPages > 0){
      for(let i=0; i<totalPages; i++){
        const opt = document.createElement('option');
        opt.value = i;
        opt.textContent = i + 1;
        if(i === currentPage) opt.selected = true;
        pageSelect.appendChild(opt);
      }
      pageSelect.disabled = false;
      pageSelect.value = String(currentPage);
    } else {
      const opt = document.createElement('option');
      opt.value = '';
      opt.textContent = '—';
      pageSelect.appendChild(opt);
      pageSelect.disabled = true;
      pageSelect.value = '';
    }
  }

  prevBtn.disabled = currentPage === 0 || totalPages === 0;
  nextBtn.disabled = (end >= list.length) || totalPages === 0;
}

/* ======= Pagination & Nav ======= */
prevBtn.addEventListener('click', ()=>{ if(currentPage>0){ currentPage--; renderAlbumsPage(); }});
nextBtn.addEventListener('click', ()=>{
  const list = getCurrentList();
  if((currentPage+1)*albumsPerPage<list.length){ currentPage++; renderAlbumsPage(); }
});

if(pageSelect){
  pageSelect.addEventListener('change', ()=>{
    const pageIndex = parseInt(pageSelect.value, 10);
    if(Number.isNaN(pageIndex) || pageIndex === currentPage) return;
    currentPage = pageIndex;
    renderAlbumsPage();
  });
}

navItems.forEach(it=>{ it.addEventListener('click', ()=>{ renderCategory(it.dataset.page); }); });

function updateManagementMode(){
  modeSwitch.textContent = managementMode;
  modeSwitch.classList.toggle('mode-k', managementMode === 'K');
  modeSwitch.setAttribute('aria-pressed', managementMode === 'K');
  modeSwitch.title = managementMode === 'F' ? 'Przełącz na kontenery' : 'Przełącz na foldery';
  newFolderBtn.title = managementMode === 'F' ? 'Dodaj folder' : 'Dodaj kontener';
  editFolderBtn.title = managementMode === 'F' ? 'Edytuj folder' : 'Edytuj kontener';
  deleteFolderBtn.title = managementMode === 'F' ? 'Usuń folder' : 'Usuń kontener';
}

modeSwitch.addEventListener('click', ()=>{
  managementMode = managementMode === 'F' ? 'K' : 'F';
  updateManagementMode();
});

containerSelect.addEventListener('change', ()=>{
  rebuildFolderSelect();
  folderSelect.value = '__all__';
  
  
});

folderSelect.addEventListener('change', ()=>{
  markFoldersPending();
});

foldersRefreshBtn.addEventListener('click', ()=>{
  clearFoldersPending();
  if(currentCategory !== 'FD'){
    renderCategory('FD');
  } else {
    currentPage = 0;
    renderAlbumsPage();
  }
});

updateManagementMode();

/* ======= Selector cycling ======= */
function cycleSelector(album, imgEl, cardEl){
  const current = album.selector || 'N';
  const order = ['N','X','F'];
  const next = order[(order.indexOf(current)+1)%order.length];
  album.selector = next;
  syncRecord(album, { selector: next });
  if(next==='X') imgEl.classList.add('grayscale'); else imgEl.classList.remove('grayscale');
  applySelectorColorToCard(cardEl,next);
  processAndRender();
}

function applySelectorColorToCard(card, selector){
  let borderColor = 'rgba(200,0,0,0.25)';
  let hoverColor = 'rgba(200,0,0,1)';
  let infoBg = '#fff';

  if(selector==='X'){
    borderColor = 'rgba(100,100,100,0.4)';
    hoverColor = 'rgba(100,100,100,1)';
    infoBg = 'rgba(100,100,100,0.4)';
  } else if(selector==='F'){
    borderColor = 'rgba(0,150,136,0.4)';
    hoverColor = 'rgba(0,150,136,1)';
    infoBg = 'rgba(0,150,136,0.4)';
  }

  card.style.setProperty('--card-border-color', borderColor);
  card.style.setProperty('--card-hover-color', hoverColor);
  card.style.setProperty('--album-info-bg', infoBg);
}

/* ======= Duration formatting ======= */
function formatDuration(seconds){
  if(!seconds || seconds<=0) return 'brak';
  const m = Math.floor(seconds/60);
  const s = seconds%60;
  return `${m}m ${s.toString().padStart(2,'0')}s`;
}

function buildWorkbook(){
  const headers = ['SELECTOR','FOLDER','KONTENER','ADDED','LABEL','LINK','PICTURE','ARTIST','TITLE','DURATION','RELEASE_DATE','Col_K','Col_F'];
  const data = records.map(rec=>{
    const releaseValue = (rec.release_original !== undefined && rec.release_original !== null && rec.release_original !== '')
      ? rec.release_original
      : (rec.release_date || 0);
    return {
      SELECTOR: rec.selector || rec.origSelector || 'N',
      FOLDER: rec.folder || 'brak',
      KONTENER: rec.container || 'brak',
      ADDED: rec.added || '',
      LABEL: rec.label || '',
      LINK: rec.link || '',
      PICTURE: rec.picture || '',
      ARTIST: rec.artist || '',
      TITLE: rec.title || '',
      DURATION: rec.duration || 0,
      RELEASE_DATE: releaseValue,
      Col_K: rec.col_k || getContainerColor(rec.container || 'brak'),
      Col_F: rec.col_f || getFolderColor(rec.folder || 'brak')
    };
  });
  const worksheet = XLSX.utils.json_to_sheet(data, { header: headers, skipHeader: false });
  const workbook = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(workbook, worksheet, currentSheetName || 'Sheet1');
  return workbook;
}

async function writeWorkbookToHandle(handle, arrayBuffer){
  const writable = await handle.createWritable();
  await writable.write(arrayBuffer);
  await writable.close();
}

/* ======= Update button (wysyłanie danych do backendu Flask) ======= */
updateBtn.addEventListener("click", async () => {
  if (!records.length) {
    alert("📂 Brak danych do zapisania! Najpierw wczytaj plik XLSX.");
    return;
  }

  try {
    const res = await fetch("http://127.0.0.1:5000/update_xlsx", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ records, sheetName: "Sheet1" })
    });

    const data = await res.json();

    if (data.status === "ok") {
      // ✅ komunikat z backendu zawiera datę i nazwę backupu
      const msg = data.message || "✅ Dane zapisane poprawnie.";
      alert(msg);
      console.info(msg);
      flashFileUpdated();
    } else {
      alert("❌ Błąd zapisu: " + (data.error || "Nieznany problem."));
      console.error(data.error || "Nieznany problem.");
    }
  } catch (err) {
    alert("❌ Serwer Flask nie jest uruchomiony.\n\n➡ Uruchom plik 'server_6.py' i spróbuj ponownie.");
    console.error("Brak połączenia z serwerem:", err);
  }
});

/* ======= Folder & container management ======= */

function isValidEntityName(name){
  if(typeof name !== 'string') return false;
  const trimmed = name.trim();
  if(!trimmed) return false;
  if(trimmed.length > 50) return false;
  return true;
}

async function handleCreateEntity(){
  if(managementMode === 'K'){
    if(getCustomContainerCount() >= 1000){
      alert('Osiągnięto limit 1000 kontenerów. Usuń istniejący, aby dodać nowy.');
      return;
    }
    const dialog = await openEntityDialog({ mode: 'container', title: 'Nowy kontener', defaultColor: DEFAULT_CONTAINER_COLOR });
    if(!dialog) return;
    const name = dialog.name;
    if(!isValidEntityName(name)){
      alert('Nieprawidłowa nazwa kontenera. Dozwolone maks. 50 znaków (w tym spacje).');
      return;
    }
    if(containersList.has(name)){
      alert('Kontener o takiej nazwie już istnieje.');
      return;
    }
    const color = dialog.color || DEFAULT_CONTAINER_COLOR;
    containersList.add(name);
    containerMeta.set(name, { color, folders: new Set() });
    rebuildContainerSelect();
    containerSelect.value = name;
    markFoldersPending();
    alert(`Utworzono kontener: ${name}`);
    return;
  }

  if(getCustomFolderCount() >= 1000){
    alert('Osiągnięto limit 1000 folderów. Usuń istniejący folder, aby dodać nowy.');
    return;
  }
  const suggestedContainer = (containerSelect.value && containerSelect.value !== '__all__') ? containerSelect.value : 'brak';
  const dialog = await openEntityDialog({ mode: 'folder', title: 'Nowy folder', defaultColor: DEFAULT_FOLDER_COLOR, defaultContainer: suggestedContainer });
  if(!dialog) return;
  const name = dialog.name;
  if(!isValidEntityName(name)){
    alert('Nieprawidłowa nazwa folderu. Dozwolone maks. 50 znaków (w tym spacje).');
    return;
  }
  if(foldersList.has(name)){
    alert('Folder o takiej nazwie już istnieje.');
    return;
  }
  const color = dialog.color || DEFAULT_FOLDER_COLOR;
  const containerName = dialog.container || 'brak';
  foldersList.add(name);
  folderMeta.set(name, { color, container: containerName });
  ensureContainerEntry(containerName).folders.add(name);
  rebuildContainerSelect();
  rebuildFolderSelect();
  if(Array.from(containerSelect.options).some(o=>o.value===containerName)){
    containerSelect.value = containerName;
  }
  folderSelect.value = name;
  markFoldersPending();
  alert(`Utworzono folder: ${name}`);
}

async function handleEditEntity(){
  if(managementMode === 'K'){
    const selected = containerSelect.value;
    if(!selected || selected === '__all__'){
      alert('Wybierz najpierw kontener do edycji.');
      return;
    }
    if(selected === 'brak'){
      alert('Kontener "brak" jest stały i nie może być edytowany.');
      return;
    }
    const meta = containerMeta.get(selected) || ensureContainerEntry(selected);
    const dialog = await openEntityDialog({ mode: 'container', title: `Edytuj kontener`, defaultName: selected, defaultColor: meta.color });
    if(!dialog) return;
    const newName = dialog.name;
    if(!isValidEntityName(newName)){
      alert('Nieprawidłowa nazwa kontenera. Dozwolone maks. 50 znaków.');
      return;
    }
    if(newName !== selected && containersList.has(newName)){
      alert('Kontener o takiej nazwie już istnieje.');
      return;
    }
    const newColor = dialog.color || meta.color || DEFAULT_CONTAINER_COLOR;
    const affectedFolders = meta.folders ? new Set(meta.folders) : new Set();
    if(newName !== selected){
      containersList.delete(selected);
      containersList.add(newName);
      containerMeta.delete(selected);
      containerMeta.set(newName, { color: newColor, folders: affectedFolders });
      folderMeta.forEach(info=>{ if(info.container === selected) info.container = newName; });
      records.forEach(r=>{
        if((sanitizeName(r.container) || 'brak') === selected){
          r.container = newName;
          r.col_k = newColor;
        }
      });
      if(folderSelect.value && folderSelect.value !== '__all__'){
        const fldMeta = folderMeta.get(folderSelect.value);
        if(fldMeta) fldMeta.container = fldMeta.container;
      }
      alert(`Zmieniono kontener: ${selected} → ${newName}`);
    } else {
      meta.color = newColor;
      records.forEach(r=>{
        if((sanitizeName(r.container) || 'brak') === selected){
          r.col_k = newColor;
        }
      });
      alert(`Zaktualizowano kolor kontenera: ${selected}`);
    }
    rebuildContainerSelect();
    rebuildFolderSelect();
    containerSelect.value = newName;
    markFoldersPending();
    processAndRender();
    return;
  }

  const selected = folderSelect.value;
  if(!selected || selected === '__all__'){
    alert('Wybierz najpierw folder do edycji.');
    return;
  }
  if(selected === 'brak'){
    alert('Folder "brak" jest stały i nie może być edytowany.');
    return;
  }
  const meta = folderMeta.get(selected) || { color: DEFAULT_FOLDER_COLOR, container: 'brak' };
  const dialog = await openEntityDialog({ mode: 'folder', title: `Edytuj folder`, defaultName: selected, defaultColor: meta.color, defaultContainer: meta.container || 'brak' });
  if(!dialog) return;
  const newName = dialog.name;
  if(!isValidEntityName(newName)){
    alert('Nieprawidłowa nazwa folderu. Dozwolone maks. 50 znaków.');
    return;
  }
  if(newName !== selected && foldersList.has(newName)){
    alert('Folder o takiej nazwie już istnieje.');
    return;
  }
  const newColor = dialog.color || meta.color || DEFAULT_FOLDER_COLOR;
  const newContainer = dialog.container || 'brak';
  const prevContainer = meta.container || 'brak';

  if(newName !== selected){
    foldersList.delete(selected);
    foldersList.add(newName);
    folderMeta.delete(selected);
  }
  folderMeta.set(newName, { color: newColor, container: newContainer });

  if(prevContainer && containerMeta.has(prevContainer)){
    containerMeta.get(prevContainer).folders.delete(selected);
  }
  ensureContainerEntry(newContainer).folders.add(newName);

  records.forEach(r=>{
    if(r.folder === selected){
      r.folder = newName;
      r.container = newContainer;
      r.col_f = newColor;
      r.col_k = getContainerColor(newContainer);
    }
  });

  rebuildContainerSelect();
  rebuildFolderSelect();
  if(Array.from(containerSelect.options).some(o=>o.value===newContainer)){
    containerSelect.value = newContainer;
  }
  folderSelect.value = newName;
  markFoldersPending();
  processAndRender();
  if(newName !== selected){
    alert(`Zaktualizowano folder: ${selected} → ${newName}`);
  } else {
    alert(`Zaktualizowano folder: ${newName}`);
  }
}

function handleDeleteEntity(){
  if(managementMode === 'K'){
    const selected = containerSelect.value;
    if(!selected || selected === '__all__'){
      alert('Wybierz najpierw kontener do usunięcia.');
      return;
    }
    if(selected === 'brak'){
      alert('Kontener "brak" nie może zostać usunięty.');
      return;
    }
    const ok = confirm(`Usunąć kontener "${selected}"? Wszystkie foldery zostaną przypisane do kontenera "brak".`);
    if(!ok) return;
    const meta = containerMeta.get(selected) || { folders: new Set() };
    const affected = meta.folders ? Array.from(meta.folders) : [];
    affected.forEach(fld => {
      const info = folderMeta.get(fld);
      if(info){ info.container = 'brak'; }
      ensureContainerEntry('brak').folders.add(fld);
    });
    records.forEach(r=>{
      if((sanitizeName(r.container) || 'brak') === selected){
        r.container = 'brak';
        r.col_k = getContainerColor('brak');
      }
    });
    containerMeta.delete(selected);
    containersList.delete(selected);
    rebuildContainerSelect();
    rebuildFolderSelect();
    containerSelect.value = '__all__';
    markFoldersPending();
    processAndRender();
    alert(`Usunięto kontener: ${selected}`);
    return;
  }

  const selected = folderSelect.value;
  if(!selected || selected === '__all__'){
    alert('Wybierz najpierw folder do usunięcia.');
    return;
  }
  if(selected === 'brak'){
    alert('Folder "brak" nie może zostać usunięty.');
    return;
  }
  const ok = confirm(`Usunąć folder "${selected}"? Wszystkie albumy zostaną przeniesione do "brak".`);
  if(!ok) return;
  foldersList.delete(selected);
  const info = folderMeta.get(selected);
  if(info && info.container && containerMeta.has(info.container)){
    containerMeta.get(info.container).folders.delete(selected);
  }
  folderMeta.delete(selected);
  records.forEach(r=>{
    if(r.folder === selected){
      r.folder = 'brak';
      r.container = 'brak';
      r.added = '';
      r.added_ts = 0;
      r.col_f = DEFAULT_EMPTY_COLOR;
      r.col_k = getContainerColor('brak');
    }
  });
  rebuildContainerSelect();
  rebuildFolderSelect();
  folderSelect.value = '__all__';
  markFoldersPending();
  processAndRender();
  alert(`Usunięto folder: ${selected}`);
}

newFolderBtn.addEventListener('click', ()=>{ handleCreateEntity(); });
editFolderBtn.addEventListener('click', ()=>{ handleEditEntity(); });
deleteFolderBtn.addEventListener('click', ()=>{ handleDeleteEntity(); });

exportFolderBtn.addEventListener('click', ()=>{
  const selected = folderSelect.value;
  if(!selected || selected === '__all__'){
    alert('Wybierz najpierw konkretny folder do eksportu.');
    return;
  }
  const links = records.filter(r=> (r.folder || 'brak') === selected && r.link).map(r=>r.link);
  const content = links.join('\n');
  const blob = new Blob([content], {type:'text/plain;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url;
  // ensure filename safe
  const filename = `${selected}.txt`;
  a.download = filename;
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  alert(`✅ Wyeksportowano ${links.length} linków do pliku ${filename}`);
});

/* ======= Date controls ======= */
dateFromInput.addEventListener('change', processAndRender);
dateToInput.addEventListener('change', processAndRender);

/* ======= Empty state ======= */
function showEmptyState(){
  albumsContainer.innerHTML = `<div style="grid-column:1/-1;padding:30px;background:#fff;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.08);">Wczytaj plik XLSX (przycisk XLSX), aby rozpocząć pracę.<br>Wymagane kolumny: SELECTOR, FOLDER, ADDED, LABEL, LINK, PICTURE, ARTIST, TITLE, DURATION, RELEASE_DATE.</div>`;
}
showEmptyState();

/* ======= Hover style injection ======= */
(function injectHoverStyle(){
  const css=document.createElement('style'); css.innerHTML=`.album-card:hover { border-color: var(--card-hover-color, rgba(200,0,0,0.85)); }`; document.head.appendChild(css);
})();

/* ======= Initial folder select build ======= */
rebuildContainerSelect();
rebuildFolderSelect();
buildLabelFilterPanel();
renderCategory(currentCategory);

/* ======= Automatyczne wczytywanie danych z serwera Flask ======= */
async function loadXlsxData() {
  try {
    const res = await fetch("http://127.0.0.1:5000/get_xlsx", { cache: "no-store" });
    if (!res.ok) throw new Error(`HTTP ${res.status}`);

    const data = await res.json();

    if (data.status === "ok" && Array.isArray(data.records) && data.records.length > 0) {
      const parsed = data.records.map(convertRowToRecord);
      applyRecordsList(parsed, {
        sheetName: data.sheet_name || "Sheet1",
        fileName: "ZAJEBISTE_DANE.xlsx",
        timestamp: Date.now()
      });

      autoDataLoaded = true;
      if (loadRetryTimer) { clearTimeout(loadRetryTimer); loadRetryTimer = null; }

      const now = new Date().toLocaleTimeString();
    const fileName = data.file_name || "ZAJEBISTE_DANE.xlsx";
    const sheetName = data.sheet_name || "Sheet1";

    fileStatusEl.textContent =
    `✅ Automatycznie wczytano plik: ${fileName} (arkusz: ${sheetName}, ${now})`;

    console.info(`📥 Wczytano ${parsed.length} rekordów z pliku ${fileName}, arkusz: ${sheetName}`);
    } else {
      // brak rekordów – spróbuj ponownie za 3 sekundy (o ile jeszcze nie mamy danych)
      if (!autoDataLoaded) {
        fileStatusEl.textContent = "⚠️ Brak danych… spróbuję ponownie za 3 s.";
        loadRetryTimer = setTimeout(loadXlsxData, 3000);
      } else {
        fileStatusEl.textContent = "⚠️ Brak danych w pliku lub pusta tabela.";
      }
    }
  } catch (err) {
    console.error("❌ Nie udało się połączyć z serwerem Flask:", err);
    if (!autoDataLoaded) {
      fileStatusEl.textContent = "❌ Serwer Flask nie działa — ponawiam za 3 s…";
      loadRetryTimer = setTimeout(loadXlsxData, 3000);
    } else {
      fileStatusEl.textContent = "❌ Utracono połączenie z serwerem.";
    }
  }
}

// Automatyczne wczytanie przy otwarciu lub odświeżeniu strony
window.addEventListener("DOMContentLoaded", loadXlsxData);

/* ======= Monitorowanie statusu serwera Flask z animacją LED i licznikiem uptime ======= */
let serverUpSince = null; // czas startu serwera
let uptimeTimer = null;   // handler setInterval

function formatUptime(seconds) {
  const m = Math.floor(seconds / 60);
  const s = seconds % 60;
  return `${m}m ${s}s`;
}

function startUptimeCounter(el) {
  if (uptimeTimer) clearInterval(uptimeTimer);
  serverUpSince = Date.now();
  uptimeTimer = setInterval(() => {
    const elapsed = Math.floor((Date.now() - serverUpSince) / 1000);
    el.textContent = `🟢 Serwer Flask działa (od ${formatUptime(elapsed)})`;
  }, 1000);
}

function stopUptimeCounter() {
  if (uptimeTimer) clearInterval(uptimeTimer);
  uptimeTimer = null;
  serverUpSince = null;
}

async function checkServerStatus() {
  const el = document.getElementById("server-status");
  try {
    const res = await fetch("http://127.0.0.1:5000/", { cache: "no-store" });
    const data = await res.json();
    if (res.ok && data.status === "ok") {
      // Jeśli serwer działa, aktualizuj LED i uruchom licznik uptime
      el.style.background = "#0a0";
      el.classList.remove("pulse-red", "pulse-gray");
      el.classList.add("pulse-green");

      if (!serverUpSince) {
        startUptimeCounter(el);
      }
    } else {
      throw new Error("Błąd HTTP");
    }
  } catch (err) {
    // Serwer nie odpowiada — wyłącz licznik i zmień stan
    el.textContent = "🔴 Serwer Flask wyłączony";
    el.style.background = "#a00";
    el.classList.remove("pulse-green", "pulse-gray");
    el.classList.add("pulse-red");
    stopUptimeCounter();
  }
}

// 🕓 Tryb "sprawdzanie" w czasie startu
function setCheckingStatus() {
  const el = document.getElementById("server-status");
  if (!el) return; // 🧱 jeśli element jeszcze nie istnieje, zakończ funkcję

  el.textContent = "🔄 Sprawdzanie serwera...";
  el.style.background = "#555";
  el.classList.remove("pulse-green", "pulse-red");
  el.classList.add("pulse-gray");
  stopUptimeCounter();
}

// 🔁 Start i cykliczne sprawdzanie co 5 sekund
window.addEventListener("DOMContentLoaded", () => {
  setCheckingStatus();     // raz: na starcie, zanim przyjdzie odpowiedź
  checkServerStatus();     // pierwszy strzał od razu
  setInterval(checkServerStatus, 5000);  // potem tylko sprawdzenie, bez resetu do "sprawdzanie"
});

</script>
<!-- ======= STATUS SERWERA (prawy dolny róg) ======= -->
<div id="server-status"
     style="
       position: fixed; bottom: 12px; right: 15px;
       background: #333; color: #fff;
       font-size: 13px; font-family: monospace;
       padding: 8px 14px; border-radius: 10px;
       opacity: 0.9; box-shadow: 0 0 6px rgba(0,0,0,0.4);
       transition: background 0.6s ease, box-shadow 0.6s ease, transform 0.3s ease;
       z-index: 999;">
  🔄 Sprawdzanie serwera...
</div>

<style>
/* ======= Pulsujące animacje LED ======= */
@keyframes pulse-green {
  0%   { box-shadow: 0 0 6px rgba(0,255,0,0.5); }
  50%  { box-shadow: 0 0 20px rgba(0,255,0,0.9); }
  100% { box-shadow: 0 0 6px rgba(0,255,0,0.5); }
}

@keyframes pulse-red {
  0%   { box-shadow: 0 0 6px rgba(255,0,0,0.5); }
  50%  { box-shadow: 0 0 20px rgba(255,0,0,0.9); }
  100% { box-shadow: 0 0 6px rgba(255,0,0,0.5); }
}

@keyframes pulse-gray {
  0%   { box-shadow: 0 0 5px rgba(180,180,180,0.3); opacity: 0.8; }
  50%  { box-shadow: 0 0 10px rgba(200,200,200,0.6); opacity: 1; }
  100% { box-shadow: 0 0 5px rgba(180,180,180,0.3); opacity: 0.8; }
}

/* Klasy stanów */
#server-status.pulse-green { animation: pulse-green 2s infinite ease-in-out; }
#server-status.pulse-red   { animation: pulse-red 2s infinite ease-in-out; }
#server-status.pulse-gray  { animation: pulse-gray 2s infinite ease-in-out; }
</style>

</body>
</html>
